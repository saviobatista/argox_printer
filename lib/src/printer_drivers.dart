// AUTO GENERATED FILE, DO NOT EDIT.
//
///Generated by `package:ffigen`.

// ignore_for_file: non_constant_identifier_names

import 'dart:io';
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart';

abstract class ArgoxLibrary {}

/// Interoperability between dart and argox printers
class ArgoxPPLA extends ArgoxLibrary {
  final String _dll = 'Winppla.dll';

  /// Holds the symbol lookup function.
  late final ffi.Pointer<T> Function<T extends ffi.NativeType>(
      String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  // ArgoxPPLA(ffi.DynamicLibrary dynamicLibrary)
  //     : _lookup = dynamicLibrary.lookup;

  /// Constructor loads library straight from plugin path
  ArgoxPPLA() {
    /// Run path means you are running $ flutter run
    /// And loads .DLL files straight from current directory
    String _runPath = [Directory.current.path, 'windows'].join('\\');

    /// Exe path means you are running a build executable
    String _exePath = [
      File(Platform.resolvedExecutable).parent.path,
      'data',
      'flutter_assets',
      'packages',
      'argox_printer',
      'windows'
    ].join('\\');

    /// Now that there are 2 paths, we try load library from 3 points, both
    /// paths and also from system32 (direct call)
    /// If neither of then are loaded will be thrown an exception
    ffi.DynamicLibrary _library;
    try {
      _library = ffi.DynamicLibrary.open([_runPath, _dll].join('\\'));
    } catch (e) {
      try {
        _library = ffi.DynamicLibrary.open([_exePath, _dll].join('\\'));
      } catch (e) {
        _library = ffi.DynamicLibrary.open(_dll);
      }
    }
    _lookup = _library.lookup;
  }

  /// The symbols are looked up with [lookup].
  ArgoxPPLA.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int A_Bar2d_Maxi(
    int x,
    int y,
    int primary,
    int secondary,
    int country,
    int service,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_Maxi(
      x,
      y,
      primary,
      secondary,
      country,
      service,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_MaxiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_Maxi');
  late final _A_Bar2d_Maxi = _A_Bar2d_MaxiPtr.asFunction<
      int Function(
          int, int, int, int, int, int, int, int, ffi.Pointer<ffi.Int8>)>();

  int A_Bar2d_Maxi_Ori(
    int x,
    int y,
    int ori,
    int primary,
    int secondary,
    int country,
    int service,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_Maxi_Ori(
      x,
      y,
      ori,
      primary,
      secondary,
      country,
      service,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_Maxi_OriPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_Maxi_Ori');
  late final _A_Bar2d_Maxi_Ori = _A_Bar2d_Maxi_OriPtr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  int A_Bar2d_PDF417(
    int x,
    int y,
    int narrow,
    int width,
    int normal,
    int security,
    int aspect,
    int row,
    int column,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_PDF417(
      x,
      y,
      narrow,
      width,
      normal,
      security,
      aspect,
      row,
      column,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_PDF417Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_PDF417');
  late final _A_Bar2d_PDF417 = _A_Bar2d_PDF417Ptr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  int A_Bar2d_PDF417_Ori(
    int x,
    int y,
    int ori,
    int narrow,
    int width,
    int normal,
    int security,
    int aspect,
    int row,
    int column,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_PDF417_Ori(
      x,
      y,
      ori,
      narrow,
      width,
      normal,
      security,
      aspect,
      row,
      column,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_PDF417_OriPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_PDF417_Ori');
  late final _A_Bar2d_PDF417_Ori = _A_Bar2d_PDF417_OriPtr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  int A_Bar2d_DataMatrix(
    int x,
    int y,
    int rotation,
    int hor_mul,
    int ver_mul,
    int ECC,
    int data_format,
    int num_rows,
    int num_col,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_DataMatrix(
      x,
      y,
      rotation,
      hor_mul,
      ver_mul,
      ECC,
      data_format,
      num_rows,
      num_col,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_DataMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_DataMatrix');
  late final _A_Bar2d_DataMatrix = _A_Bar2d_DataMatrixPtr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  void A_Clear_Memory() {
    return _A_Clear_Memory();
  }

  late final _A_Clear_MemoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('A_Clear_Memory');
  late final _A_Clear_Memory = _A_Clear_MemoryPtr.asFunction<void Function()>();

  /// *******************************************************************************
  /// A_ClosePrn()
  /// ===============================================================================
  /// PURPOSE   Stop printer operation.
  /// SYNTAX
  ///     void aClosePrn(void);
  /// EXAMPLE
  ///     aClosePrn();
  /// REMARK  The aClosePrn function will access the port that you choiced or close
  ///     file. The function must be performed after all commands placed.
  void A_ClosePrn() {
    return _A_ClosePrn();
  }

  late final _A_ClosePrnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('A_ClosePrn');
  late final _A_ClosePrn = _A_ClosePrnPtr.asFunction<void Function()>();

  int A_CreatePrn(
    int selection,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _A_CreatePrn(
      selection,
      filename,
    );
  }

  late final _A_CreatePrnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Int8>)>>('A_CreatePrn');
  late final _A_CreatePrn =
      _A_CreatePrnPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int8>)>();

  int A_Del_Graphic(
    int mem_mode,
    ffi.Pointer<ffi.Int8> graphic,
  ) {
    return _A_Del_Graphic(
      mem_mode,
      graphic,
    );
  }

  late final _A_Del_GraphicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('A_Del_Graphic');
  late final _A_Del_Graphic =
      _A_Del_GraphicPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int8>)>();

  int A_Draw_Box(
    int mode,
    int x,
    int y,
    int width,
    int height,
    int top,
    int side,
  ) {
    return _A_Draw_Box(
      mode,
      x,
      y,
      width,
      height,
      top,
      side,
    );
  }

  late final _A_Draw_BoxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int8, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32, ffi.Int32)>>('A_Draw_Box');
  late final _A_Draw_Box = _A_Draw_BoxPtr.asFunction<
      int Function(int, int, int, int, int, int, int)>();

  int A_Draw_Line(
    int mode,
    int x,
    int y,
    int width,
    int height,
  ) {
    return _A_Draw_Line(
      mode,
      x,
      y,
      width,
      height,
    );
  }

  late final _A_Draw_LinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int8, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32)>>('A_Draw_Line');
  late final _A_Draw_Line =
      _A_Draw_LinePtr.asFunction<int Function(int, int, int, int, int)>();

  void A_Feed_Label() {
    return _A_Feed_Label();
  }

  late final _A_Feed_LabelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('A_Feed_Label');
  late final _A_Feed_Label = _A_Feed_LabelPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Int8> A_Get_DLL_Version(
    int nShowMessage,
  ) {
    return _A_Get_DLL_Version(
      nShowMessage,
    );
  }

  late final _A_Get_DLL_VersionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int8> Function(ffi.Int32)>>(
          'A_Get_DLL_Version');
  late final _A_Get_DLL_Version =
      _A_Get_DLL_VersionPtr.asFunction<ffi.Pointer<ffi.Int8> Function(int)>();

  int A_Get_DLL_VersionA(
    int nShowMessage,
  ) {
    return _A_Get_DLL_VersionA(
      nShowMessage,
    );
  }

  late final _A_Get_DLL_VersionAPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Get_DLL_VersionA');
  late final _A_Get_DLL_VersionA =
      _A_Get_DLL_VersionAPtr.asFunction<int Function(int)>();

  int A_Get_Graphic(
    int x,
    int y,
    int mem_mode,
    int format,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _A_Get_Graphic(
      x,
      y,
      mem_mode,
      format,
      filename,
    );
  }

  late final _A_Get_GraphicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int8,
              ffi.Pointer<ffi.Int8>)>>('A_Get_Graphic');
  late final _A_Get_Graphic = _A_Get_GraphicPtr.asFunction<
      int Function(int, int, int, int, ffi.Pointer<ffi.Int8>)>();

  int A_Get_Graphic_ColorBMP(
    int x,
    int y,
    int mem_mode,
    int format,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _A_Get_Graphic_ColorBMP(
      x,
      y,
      mem_mode,
      format,
      filename,
    );
  }

  late final _A_Get_Graphic_ColorBMPPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int8,
              ffi.Pointer<ffi.Int8>)>>('A_Get_Graphic_ColorBMP');
  late final _A_Get_Graphic_ColorBMP = _A_Get_Graphic_ColorBMPPtr.asFunction<
      int Function(int, int, int, int, ffi.Pointer<ffi.Int8>)>();

  int A_Get_Graphic_ColorBMPEx(
    int x,
    int y,
    int nWidth,
    int nHeight,
    int rotate,
    int mem_mode,
    int format,
    ffi.Pointer<ffi.Int8> id_name,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _A_Get_Graphic_ColorBMPEx(
      x,
      y,
      nWidth,
      nHeight,
      rotate,
      mem_mode,
      format,
      id_name,
      filename,
    );
  }

  late final _A_Get_Graphic_ColorBMPExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('A_Get_Graphic_ColorBMPEx');
  late final _A_Get_Graphic_ColorBMPEx =
      _A_Get_Graphic_ColorBMPExPtr.asFunction<
          int Function(int, int, int, int, int, int, int, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>();

  int A_Get_Graphic_ColorBMP_HBitmap(
    int x,
    int y,
    int nWidth,
    int nHeight,
    int rotate,
    int mem_mode,
    int format,
    ffi.Pointer<ffi.Int8> id_name,
    int hbm,
  ) {
    return _A_Get_Graphic_ColorBMP_HBitmap(
      x,
      y,
      nWidth,
      nHeight,
      rotate,
      mem_mode,
      format,
      id_name,
      hbm,
    );
  }

  late final _A_Get_Graphic_ColorBMP_HBitmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('A_Get_Graphic_ColorBMP_HBitmap');
  late final _A_Get_Graphic_ColorBMP_HBitmap =
      _A_Get_Graphic_ColorBMP_HBitmapPtr.asFunction<
          int Function(
              int, int, int, int, int, int, int, ffi.Pointer<ffi.Int8>, int)>();

  int A_Initial_Setting(
    int Type,
    ffi.Pointer<ffi.Int8> Source,
  ) {
    return _A_Initial_Setting(
      Type,
      Source,
    );
  }

  late final _A_Initial_SettingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('A_Initial_Setting');
  late final _A_Initial_Setting = _A_Initial_SettingPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>)>();

  ///*******************************************************************************
  ///A_WriteData()
  ///===============================================================================
  ///PURPOSE   To output data immediately or send it to temporary area.
  ///SYNTAX
  ///    int A_WriteData(int IsImmediate, String pbuf, int length);
  ///PARAMETER
  ///    IsImmediate;
  ///      1 that the data should be sent immediately, and only the data in pbuf should
  ///      be sent to the output port;
  ///      0 that the data is to be stored to the temporary area and will only be sent
  ///      when aPrintOut() is called.
  ///    pbuf;
  ///      The data pointer to be sent.
  ///    length;
  ///      Length of pbuf data.
  ///RETURN
  ///    0 -> OK.
  ///    Reference AW-Error.txt file.
  ///EXAMPLE
  ///    Stringsznop1 = "nop_front\r\n";
  ///    String sznop2 = "nop_middle\r\n";
  ///    A_WriteData(0, sznop2, sznop1.length);
  ///    A_WriteData(1, sznop1, sznop1.length);
  ///REMARK  Any controls, commands or data that you wish to send to the printer can
  ///    be sent via this function.
  int A_WriteData(
    int IsImmediate,
    String pbuf,
    int length,
  ) {
    return _A_WriteData(
      IsImmediate,
      pbuf.toNativeUtf8().cast<ffi.Int8>(),
      length, // I could use pbuf.length here but would change manufacturer standard
    );
  }

  late final _A_WriteDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>, ffi.Int32)>>('A_WriteData');
  late final _A_WriteData = _A_WriteDataPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, int)>();

  int A_ReadData(
    ffi.Pointer<ffi.Int8> pbuf,
    int length,
    int dwTimeoutms,
  ) {
    return _A_ReadData(
      pbuf,
      length,
      dwTimeoutms,
    );
  }

  late final _A_ReadDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int8>, ffi.Int32, ffi.Int32)>>('A_ReadData');
  late final _A_ReadData = _A_ReadDataPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, int, int)>();

  int A_Load_Graphic(
    int x,
    int y,
    ffi.Pointer<ffi.Int8> graphic_name,
  ) {
    return _A_Load_Graphic(
      x,
      y,
      graphic_name,
    );
  }

  late final _A_Load_GraphicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Int8>)>>('A_Load_Graphic');
  late final _A_Load_Graphic = _A_Load_GraphicPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Int8>)>();

  int A_Open_ChineseFont(
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _A_Open_ChineseFont(
      path,
    );
  }

  late final _A_Open_ChineseFontPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'A_Open_ChineseFont');
  late final _A_Open_ChineseFont =
      _A_Open_ChineseFontPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  int A_Print_Form(
    int width,
    int height,
    int copies,
    int amount,
    ffi.Pointer<ffi.Int8> form_name,
  ) {
    return _A_Print_Form(
      width,
      height,
      copies,
      amount,
      form_name,
    );
  }

  late final _A_Print_FormPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Print_Form');
  late final _A_Print_Form = _A_Print_FormPtr.asFunction<
      int Function(int, int, int, int, ffi.Pointer<ffi.Int8>)>();

  /// *******************************************************************************
  /// A_PrintOut()
  /// ===============================================================================
  /// PURPOSE   Perform printing function.
  /// SYNTAX
  ///     int A_PrintOut(int width, int height, int copies, int amount);
  /// PARAMETER
  ///     width;
  ///       Width - 1 or 2.
  ///     height;
  ///       Height - 1, 2 or 3.
  ///     copies;
  ///       Specifes the label quantity. Value:1 ~ 9999.
  ///     amount;
  ///       Specifies the number of labels to be generated before incrementing/decrementing
  ///       the fields. Value:1 ~ 99.
  /// RETURN
  ///     0 -> OK.
  ///     Reference AW-Error.txt file.
  /// EXAMPLE
  ///     A_PrintOut(1, 1, 3, 1);
  /// REMARK  The A_PrintOut function access data of all commands. This command has
  ///     to be placed after all function and before aClosePrn().The width and
  ///     height parameter is setting width and height pixel size. You can set
  ///     the pixel size except the smallest one by this function. Reducing the
  ///     resolution will causes the image pixel to be amplified and generate the
  ///     zigzag output. The amount parameter can be used to incrementing or
  ///     decrementing field values more than one label which can be set only
  ///     once during label formatting mode.
  int A_Print_Out(
    int width,
    int height,
    int copies,
    int amount,
  ) {
    assert(width == 1 || width == 2, 'width value must be 1 or 2.');
    assert(height == 1 || height == 2 || height == 3,
        'height value must be 1, 2 or 3.');
    assert(copies >= 1 && copies <= 9999, 'copies must be between 1 and 9999');
    assert(amount >= 1 && amount <= 99, 'amount must be between 1 and 99');
    return _A_Print_Out(
      width,
      height,
      copies,
      amount,
    );
  }

  late final _A_Print_OutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>('A_Print_Out');
  late final _A_Print_Out =
      _A_Print_OutPtr.asFunction<int Function(int, int, int, int)>();

  ///*******************************************************************************
  ///A_Prn_Barcode()
  ///===============================================================================
  ///PURPOSE   Create a "barcode" object.
  ///SYNTAX
  ///    int A_Prn_Barcode(int x, int y, int ori, String type, int narrow, int width,
  ///      int height, String mode, int numeric, String data);
  ///PARAMETER
  ///    x;
  ///      X coordinate.
  ///    y;
  ///      Y coordinate.
  ///    ori;
  ///      Orientation or print direction, 1:0�X�B2:90�X�B3:180�X�B4:270�X
  ///    type;
  ///      Bar code type as follows:
  ///      +==========================================================================+
  ///      |Bar code    |Length    |Check|Type for|Type for   |Valid        |Bar ratio|
  ///      |            |          |sum  |readable|nonreadable|codes        |         |
  ///      |            |          |     |string  |string     |             |         |
  ///      +============+==========+=====+========+===========+=============+=========+
  ///      |Code 3 of 9 |variable  |no   |'A'     |'a'        |0~9,A~Z,$%*+-|2:1~     |
  ///      |            |          |     |        |           |./and space  |3:1      |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UPC-A       |12 digis  |yes  |'B'     |'b'        |0~9          |2:3:4    |
  ///      |            |(11+1)    |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UPC-E       |7 digits  |yes  |'C'     |'c'        |0~9          |2:3:4    |
  ///      |            |(6+1)     |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Interleaved |variable  |no   |'D'     |'d'        |0~9          |2:1~     |
  ///      |2 of 5 (I25)|          |     |        |           |             |3:1      |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Code 128    |variable  |yes  |'E'     |'e'        |form code 0  |2:3:4    |
  ///      |            |          |     |        |           |to 127(Note1)|         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |EAN-13      |13 digits |yes  |'F'     |'f'        |0~9          |2:3:4    |
  ///      |            |(12+1)    |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |ENA-8       |8 digits  |yes  |'G'     |'g'        |0~9          |2:3:4    |
  ///      |            |(7+1)     |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |HBIC        |variable  |yes  |'H'     |'h'        |0~9,A~Z,$%*+-|2:1~     |
  ///      |            |          |     |        |           |./and space  |3:1      |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Coda bar    |at least 3|no   |'I'     |'i'        |0~9,A~Z,$+-. |2:1~     |
  ///      |            |characters|     |        |           |And /        |3:1      |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Interleaved |variable  |yes  |'J'     |'j'        |0~9          |2:1~     |
  ///      |2 of 5 with +----------+     |        |           |             |3:1      |
  ///      |a modulo 10 checksum   |     |        |           |             |         |
  ///      +-----------------------+-----+--------+-----------+-------------+---------+
  ///      |Plessey     |1~14      |yes  |'K'     |'k'        |0~9          |2:1~     |
  ///      |            |digits    |     |        |           |             |3:1      |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Interleaved |variable  |yes  |'L'     |'l'        |0~9          |2:1~     |
  ///      |2 of 5 with +----------+-----+--------+-----------+             |3:1      |
  ///      |a modulo 10 checksum and shipping bearer bars     |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UPC2        |2 digits  |no   |'M'     |'m'        |0~9          |2:3:4    |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UPC5        |5 digits  |no   |'N'     |'n'        |0~9          |2:3:4    |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Code 93     |variable  |no   |'O'     |'o'        |0~9,A~Z,$%*+-|2:3:4    |
  ///      |            |          |     |        |           |./and space  |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Postnet     |variable  |yes  |not     |'p'        |0~9          |         |
  ///      |            |          |     |defined |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UCC/EAN Code|20 digits |yes  |'Q'     |'q'        |0~9          |2:3:4    |
  ///      |128         |(19+1)    |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UCC/EAN Code|18 digits |yes  |'R'     |'r'        |0~9          |2:3:4    |
  ///      |128 k-MART  |          |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |UCC/EAN Code|variable  |yes  |'S'     |'s'        |0~9          |2:3:4    |
  ///      |128 Random  |          |     |        |           |             |         |
  ///      |weight      |          |     |        |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |Telepen     |variable  |yes  |'T'     |'t'        |form code 0  |2:3:4    |
  ///      |            |          |     |        |           |to 127       |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      |FIM         |1         |no   |not     |'v'        |A,B,C and D  |         |
  ///      |            |character |     |defined |           |             |         |
  ///      +------------+----------+-----+--------+-----------+-------------+---------+
  ///      Note1: The Code 128 supports subsets A, B, and C. The default code subset is B;
  ///             otherwise, the first character (A, B, C) of the data field determines
  ///             the subset. So in order to prevent misjudgment, please additional
  ///             a character (A, B, C) before your data.
  ///             Example: subset = B
  ///                      barcode data = "Bar code"
  ///                      output = "BBar code"
  ///      Note: Please refer to the Argox PPLA Programmer Manual Section
  ///      "A10. PROGRAMMING EXAMPLES FOR BAR CODES"
  ///    narrow;
  ///      Define the narrow bar width from 0 ~ 24.
  ///    width;
  ///      Define the wide bar width from 0 ~ 24.
  ///      Note: The values of narrow and width must consult the proportion of bar ratio on forms.
  ///    height;
  ///      Bar code height. Value:0 ~ 999.
  ///    mode;
  ///      Add function as follows:
  ///      +----+-------------------------------------+
  ///      |mode|           REMARK                    |
  ///      +----+-------------------------------------+
  ///      | A  |Make auto increment for numeric.     |
  ///      +----+-------------------------------------+
  ///      | B  |Make auto increment for alphanumeric.|
  ///      +----+-------------------------------------+
  ///      | C  |Make auto decrement for numeric.     |
  ///      +----+-------------------------------------+
  ///      | D  |Make auto decrement for alphanumeric.|
  ///      +----+-------------------------------------+
  ///      | N  |Disable.                             |
  ///      +----+-------------------------------------+
  ///    numeric;
  ///      Automaticall increment or decrement the filed value. Value:0 ~ 99.
  ///      This field must exist When has add function.
  ///    data;
  ///      Data string.
  ///RETURN
  ///    0 -> OK.
  ///    Reference AW-Error.txt file.
  ///EXAMPLE
  ///    A_Prn_Barcode(150, 20, 4, 'A', 0, 0, 20, 'B', 1, "ABCD");
  ///REMARK  The A_Prn_Barcode function can print a special Barcode�C
  int A_Prn_Barcode(
    int x,
    int y,
    int ori,
    String type,
    int narrow,
    int width,
    int height,
    String mode,
    int numeric,
    String data,
  ) {
    List<String> types = [
      'A',
      'a',
      'B',
      'b',
      'C',
      'c',
      'D',
      'd',
      'E',
      'e',
      'F',
      'f',
      'G',
      'g',
      'H',
      'h',
      'I',
      'i',
      'J',
      'j',
      'K',
      'k',
      'L',
      'l',
      'M',
      'm',
      'N',
      'n',
      'O',
      'o',
      'p',
      'Q',
      'q',
      'R',
      'r',
      'S',
      's',
      'T',
      't',
      'v'
    ];
    assert(types.contains(type), 'Invalid type!');
    assert(narrow >= 0 && narrow <= 24, 'narrow must be between 0 and 24.');
    assert(width >= 0 && width <= 24, 'width must be between 0 and 24.');
    assert(height >= 0 && height <= 999, 'height must be between 0 and 999.');
    assert(['A', 'B', 'C', 'D', 'N'].contains(mode), 'Invalid mode!');
    assert(numeric >= 0 && numeric <= 99, 'numeric must be between 0 and 99.');
    return _A_Prn_Barcode(
      x,
      y,
      ori,
      type.codeUnitAt(0),
      narrow,
      width,
      height,
      mode.codeUnitAt(0),
      numeric,
      data.toNativeUtf8().cast<ffi.Int8>(),
    );
  }

  late final _A_Prn_BarcodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Prn_Barcode');
  late final _A_Prn_Barcode = _A_Prn_BarcodePtr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  ///*******************************************************************************
  ///A_Prn_Text()
  ///===============================================================================
  ///PURPOSE   Create a "text" object.
  ///SYNTAX
  ///    int A_Prn_Text(int x, int y, int ori, int font, int type, int hor_factor,
  ///        int ver_factor, char mode, int numeric, LPCTSTR data);
  ///PARAMETER
  ///    x;
  ///      X coordinate.
  ///    y;
  ///      Y coordinate.
  ///    ori;
  ///      Orientation or print direction, 1:0�X�B2:90�X�B3:180�X�B4:270�X
  ///    font;
  ///      Font type as follows:
  ///      Note:Refer to the font tables in User's Manual.
  ///    type;
  ///      As follows:
  ///      +--------------+-----+---------------------------+
  ///      |font          |type |Font Type                  |
  ///      +--------------+-----+---------------------------+
  ///      |0,1,2,3,4,5,6,|0    |font 0~font 8 respectively.|
  ///      |7,8           |     |                           |
  ///      +--------------+-----+---------------------------+
  ///      |9             |0~7  |ASD smooth fonts.          |
  ///      |              |     |0:4points,  1:6points,     |
  ///      |              |     |2:8points,  3:10points,    |
  ///      |              |     |4:12points, 5:14points,    |
  ///      |              |     |6:18points.                |
  ///      +--------------+-----+---------------------------+
  ///      |9             |xxx  |PCL soft font.             |
  ///      |              |     |xxx : soft font ID with    |
  ///      |              |     |      3 digits             |
  ///      +--------------+-----+---------------------------+
  ///      |11            |0~7  |Courier fonts,(0 represents|
  ///      |              |     |symbol set)                |
  ///      |              |     |0:Roman-8,  1:ECMA-94,     |
  ///      |              |     |2:PC set,   3:PC set A,    |
  ///      |              |     |4:PC set B, 5:Legal,       |
  ///      |              |     |6:Greek,    7:Russian.     |
  ///      +--------------+-----+---------------------------+
  ///      |12            |0    |Font selection form font   |
  ///      |              |     |board.                     |
  ///      +--------------+-----+---------------------------+
  ///    hor_factor;
  ///      Horizontal scale factor.  Value:1 ~ 24
  ///    ver_factor;
  ///      Vertical scale factor.    Value:1 ~ 24
  ///    mode;
  ///      Add function as follows:
  ///      +----+-------------------------------------+
  ///      |mode|           REMARK                    |
  ///      +----+-------------------------------------+
  ///      | A  |Make auto increment for numeric.     |
  ///      +----+-------------------------------------+
  ///      | B  |Make auto increment for alphanumeric.|
  ///      +----+-------------------------------------+
  ///      | C  |Make auto decrement for numeric.     |
  ///      +----+-------------------------------------+
  ///      | D  |Make auto decrement for alphanumeric.|
  ///      +----+-------------------------------------+
  ///      | M  |Toggle the mirror mode.              |
  ///      +----+-------------------------------------+
  ///      | N  |Disable.                             |
  ///      +----+-------------------------------------+
  ///    numeric;
  ///      Automaticall increment or decrement the filed value. Value:0 ~ 99.
  ///      This field must exist When has add function.
  ///    data;
  ///      Data string.
  ///RETURN
  ///    0 -> OK.
  ///    Reference AW-Error.txt file.
  ///EXAMPLE
  ///    A_Prn_Text(310, 35, 1, 9, 0, 1, 1, 'N', 2, "PPLA COMMAND");
  ///REMARK  The A_Prn_Text function can print a line text.
  int A_Prn_Text(
    int x,
    int y,
    int ori,
    int font,
    int type,
    int hor_factor,
    int ver_factor,
    String mode,
    int numeric,
    String data,
  ) {
    assert(hor_factor >= 1 && hor_factor <= 24,
        'hor_factor must be between 1 and 24');
    assert(ver_factor >= 1 && ver_factor <= 24,
        'ver_factor must be between 1 and 24');
    assert(['A', 'B', 'C', 'D', 'M', 'N'].contains(mode),
        'Only allowed mode values: A, B, C, D, M, N.');
    return _A_Prn_Text(
      x,
      y,
      ori,
      font,
      type,
      hor_factor,
      ver_factor,
      mode.codeUnitAt(0),
      numeric,
      data.toNativeUtf8().cast<ffi.Int8>(),
    );
  }

  late final _A_Prn_TextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Prn_Text');
  late final _A_Prn_Text = _A_Prn_TextPtr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  int A_Prn_Text_Chinese(
    int x,
    int y,
    int fonttype,
    ffi.Pointer<ffi.Int8> id_name,
    ffi.Pointer<ffi.Int8> data,
    int mem_mode,
  ) {
    return _A_Prn_Text_Chinese(
      x,
      y,
      fonttype,
      id_name,
      data,
      mem_mode,
    );
  }

  late final _A_Prn_Text_ChinesePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('A_Prn_Text_Chinese');
  late final _A_Prn_Text_Chinese = _A_Prn_Text_ChinesePtr.asFunction<
      int Function(
          int, int, int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int A_Prn_Text_TrueType(
    int x,
    int y,
    int FSize,
    ffi.Pointer<ffi.Int8> FType,
    int Fspin,
    int FWeight,
    int FItalic,
    int FUnline,
    int FStrikeOut,
    ffi.Pointer<ffi.Int8> id_name,
    ffi.Pointer<ffi.Int8> data,
    int mem_mode,
  ) {
    return _A_Prn_Text_TrueType(
      x,
      y,
      FSize,
      FType,
      Fspin,
      FWeight,
      FItalic,
      FUnline,
      FStrikeOut,
      id_name,
      data,
      mem_mode,
    );
  }

  late final _A_Prn_Text_TrueTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('A_Prn_Text_TrueType');
  late final _A_Prn_Text_TrueType = _A_Prn_Text_TrueTypePtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Int8>, int, int, int, int,
          int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int A_Prn_Text_TrueType_W(
    int x,
    int y,
    int FHeight,
    int FWidth,
    ffi.Pointer<ffi.Int8> FType,
    int Fspin,
    int FWeight,
    int FItalic,
    int FUnline,
    int FStrikeOut,
    ffi.Pointer<ffi.Int8> id_name,
    ffi.Pointer<ffi.Int8> data,
    int mem_mode,
  ) {
    return _A_Prn_Text_TrueType_W(
      x,
      y,
      FHeight,
      FWidth,
      FType,
      Fspin,
      FWeight,
      FItalic,
      FUnline,
      FStrikeOut,
      id_name,
      data,
      mem_mode,
    );
  }

  late final _A_Prn_Text_TrueType_WPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('A_Prn_Text_TrueType_W');
  late final _A_Prn_Text_TrueType_W = _A_Prn_Text_TrueType_WPtr.asFunction<
      int Function(int, int, int, int, ffi.Pointer<ffi.Int8>, int, int, int,
          int, int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int A_Set_Backfeed(
    int back,
  ) {
    return _A_Set_Backfeed(
      back,
    );
  }

  late final _A_Set_BackfeedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_Backfeed');
  late final _A_Set_Backfeed =
      _A_Set_BackfeedPtr.asFunction<int Function(int)>();

  int A_Set_BMPSave(
    int nSave,
    ffi.Pointer<ffi.Int8> pstrBMPFName,
  ) {
    return _A_Set_BMPSave(
      nSave,
      pstrBMPFName,
    );
  }

  late final _A_Set_BMPSavePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('A_Set_BMPSave');
  late final _A_Set_BMPSave =
      _A_Set_BMPSavePtr.asFunction<int Function(int, ffi.Pointer<ffi.Int8>)>();

  int A_Set_Cutting(
    int cutting,
  ) {
    return _A_Set_Cutting(
      cutting,
    );
  }

  late final _A_Set_CuttingPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_Cutting');
  late final _A_Set_Cutting = _A_Set_CuttingPtr.asFunction<int Function(int)>();

  ///*******************************************************************************
  ///A_Set_Darkness();
  ///===============================================================================
  ///PURPOSE   Setup the "darkness" function (heating level).
  ///SYNTAX
  ///    int A_Set_Darkness(int heat);
  ///PARAMETER
  ///    heat;
  ///      Set heat value(0 ~ 20). Default value 10.
  ///RETURN
  ///    0 -> OK.
  ///    Reference AW-Error.txt file.
  ///EXAMPLE
  ///    A_Set_Darkness(12);
  ///REMARK  Heat value will define the image's darkness. To get a printout with
  ///    better quality, you should consider following factors i.e. media material,
  ///    ribbon types(wax,semi-resin and resin) and image pattern itself.
  int A_Set_Darkness(
    int heat,
  ) {
    assert(heat >= 0 && heat <= 20, 'Input an heat value between 0 and 20');
    return _A_Set_Darkness(
      heat,
    );
  }

  late final _A_Set_DarknessPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_Darkness');
  late final _A_Set_Darkness =
      _A_Set_DarknessPtr.asFunction<int Function(int)>();

  ///*******************************************************************************
  ///A_Set_DebugDialog()
  ///===============================================================================
  ///PURPOSE   Enable Debug Message Dialog.
  ///SYNTAX
  ///    int A_Set_DebugDialog(int nEnable);
  ///PARAMETER
  ///    nEnable;
  ///      1 -> Enable. 0 -> Disable.
  ///RETURN
  ///    0 -> OK.
  ///    Reference AW-Error.txt file.
  ///EXAMPLE
  ///    A_Set_DebugDialog(1);
  ///REMARK  The A_Set_DebugDialog function set debug message dialog.
  int A_Set_DebugDialog(
    int nEnable,
  ) {
    assert(nEnable == 0 || nEnable == 1, 'Valid values are: 0, 1');
    return _A_Set_DebugDialog(
      nEnable,
    );
  }

  late final _A_Set_DebugDialogPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_DebugDialog');
  late final _A_Set_DebugDialog =
      _A_Set_DebugDialogPtr.asFunction<int Function(int)>();

  int A_Set_Feed(
    int rate,
  ) {
    return _A_Set_Feed(
      rate,
    );
  }

  late final _A_Set_FeedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int8)>>('A_Set_Feed');
  late final _A_Set_Feed = _A_Set_FeedPtr.asFunction<int Function(int)>();

  int A_Set_Form(
    ffi.Pointer<ffi.Int8> formfile,
    ffi.Pointer<ffi.Int8> form_name,
    int mem_mode,
  ) {
    return _A_Set_Form(
      formfile,
      form_name,
      mem_mode,
    );
  }

  late final _A_Set_FormPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('A_Set_Form');
  late final _A_Set_Form = _A_Set_FormPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  int A_Set_Margin(
    int position,
    int margin,
  ) {
    return _A_Set_Margin(
      position,
      margin,
    );
  }

  late final _A_Set_MarginPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
          'A_Set_Margin');
  late final _A_Set_Margin =
      _A_Set_MarginPtr.asFunction<int Function(int, int)>();

  int A_Set_Prncomport(
    int baud,
    int parity,
    int data,
    int stop,
  ) {
    return _A_Set_Prncomport(
      baud,
      parity,
      data,
      stop,
    );
  }

  late final _A_Set_PrncomportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>('A_Set_Prncomport');
  late final _A_Set_Prncomport =
      _A_Set_PrncomportPtr.asFunction<int Function(int, int, int, int)>();

  int A_Set_Prncomport_PC(
    int nBaudRate,
    int nByteSize,
    int nParity,
    int nStopBits,
    int nDsr,
    int nCts,
    int nXonXoff,
  ) {
    return _A_Set_Prncomport_PC(
      nBaudRate,
      nByteSize,
      nParity,
      nStopBits,
      nDsr,
      nCts,
      nXonXoff,
    );
  }

  late final _A_Set_Prncomport_PCPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32, ffi.Int32, ffi.Int32)>>('A_Set_Prncomport_PC');
  late final _A_Set_Prncomport_PC = _A_Set_Prncomport_PCPtr.asFunction<
      int Function(int, int, int, int, int, int, int)>();

  int A_Set_Sensor_Mode(
    int type,
    int continuous,
  ) {
    return _A_Set_Sensor_Mode(
      type,
      continuous,
    );
  }

  late final _A_Set_Sensor_ModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int8, ffi.Int32)>>(
          'A_Set_Sensor_Mode');
  late final _A_Set_Sensor_Mode =
      _A_Set_Sensor_ModePtr.asFunction<int Function(int, int)>();

  int A_Set_Speed(
    int speed,
  ) {
    return _A_Set_Speed(
      speed,
    );
  }

  late final _A_Set_SpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int8)>>('A_Set_Speed');
  late final _A_Set_Speed = _A_Set_SpeedPtr.asFunction<int Function(int)>();

  int A_Set_Syssetting(
    int transfer,
    int cut_peel,
    int length,
    int zero,
    int pause,
  ) {
    return _A_Set_Syssetting(
      transfer,
      cut_peel,
      length,
      zero,
      pause,
    );
  }

  late final _A_Set_SyssettingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.Int32)>>('A_Set_Syssetting');
  late final _A_Set_Syssetting =
      _A_Set_SyssettingPtr.asFunction<int Function(int, int, int, int, int)>();

  ///*******************************************************************************
  ///A_Set_Unit()
  ///===============================================================================
  ///PURPOSE   Setup measurement unit (metric or inches).
  ///SYNTAX
  ///    int A_Set_Unit(char unit);
  ///PARAMETER
  ///    unit;
  ///      The value of unit as follows:
  ///      +------+---------------------------+
  ///      | unit | REMARK                    |
  ///      +------+---------------------------+
  ///      |  m   | Set measurement in metric |
  ///      +------+---------------------------+
  ///      |  n   | Set measurement in inches |
  ///      +------+---------------------------+
  ///RETURN
  ///    0 -> OK.
  ///    Reference AW-Error.txt file.
  ///EXAMPLE
  ///    A_Set_Unit('n');
  ///REMARK  The A_Set_Unit function is used to set measurement in metric or inches.
  int A_Set_Unit(
    String unit,
  ) {
    assert(unit.length == 1);
    assert(unit == 'm' || unit == 'n', 'Valid values are: m, n');
    return _A_Set_Unit(
      unit.codeUnitAt(0),
    );
  }

  late final _A_Set_UnitPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int8)>>('A_Set_Unit');
  late final _A_Set_Unit = _A_Set_UnitPtr.asFunction<int Function(int)>();

  int A_Set_Gap(
    int gap,
  ) {
    return _A_Set_Gap(
      gap,
    );
  }

  late final _A_Set_GapPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('A_Set_Gap');
  late final _A_Set_Gap = _A_Set_GapPtr.asFunction<int Function(int)>();

  int A_Set_Logic(
    int logic,
  ) {
    return _A_Set_Logic(
      logic,
    );
  }

  late final _A_Set_LogicPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>('A_Set_Logic');
  late final _A_Set_Logic = _A_Set_LogicPtr.asFunction<int Function(int)>();

  int A_Set_ProcessDlg(
    int nShow,
  ) {
    return _A_Set_ProcessDlg(
      nShow,
    );
  }

  late final _A_Set_ProcessDlgPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_ProcessDlg');
  late final _A_Set_ProcessDlg =
      _A_Set_ProcessDlgPtr.asFunction<int Function(int)>();

  int A_Set_ErrorDlg(
    int nShow,
  ) {
    return _A_Set_ErrorDlg(
      nShow,
    );
  }

  late final _A_Set_ErrorDlgPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_ErrorDlg');
  late final _A_Set_ErrorDlg =
      _A_Set_ErrorDlgPtr.asFunction<int Function(int)>();

  int A_Set_LabelVer(
    int centiInch,
  ) {
    return _A_Set_LabelVer(
      centiInch,
    );
  }

  late final _A_Set_LabelVerPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_Set_LabelVer');
  late final _A_Set_LabelVer =
      _A_Set_LabelVerPtr.asFunction<int Function(int)>();

  int A_GetUSBBufferLen() {
    return _A_GetUSBBufferLen();
  }

  late final _A_GetUSBBufferLenPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('A_GetUSBBufferLen');
  late final _A_GetUSBBufferLen =
      _A_GetUSBBufferLenPtr.asFunction<int Function()>();

  int A_EnumUSB(
    ffi.Pointer<ffi.Int8> buf,
  ) {
    return _A_EnumUSB(
      buf,
    );
  }

  late final _A_EnumUSBPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'A_EnumUSB');
  late final _A_EnumUSB =
      _A_EnumUSBPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  int A_CreateUSBPort(
    int nPort,
  ) {
    return _A_CreateUSBPort(
      nPort,
    );
  }

  late final _A_CreateUSBPortPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_CreateUSBPort');
  late final _A_CreateUSBPort =
      _A_CreateUSBPortPtr.asFunction<int Function(int)>();

  int A_CreatePort(
    int nPortType,
    int nPort,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _A_CreatePort(
      nPortType,
      nPort,
      filename,
    );
  }

  late final _A_CreatePortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Int8>)>>('A_CreatePort');
  late final _A_CreatePort = _A_CreatePortPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Int8>)>();

  ///*******************************************************************************
  ///A_Clear_MemoryEx()
  ///===============================================================================
  ///PURPOSE   Clear resident memory - RAM or Flash memory.
  ///PARAMETER
  ///    nMode;
  ///      0 --> Printer Default
  ///      1 --> RAM
  ///      2 --> Flash
  ///EXAMPLE
  ///    A_Clear_MemoryEx(1);
  ///REMARK  The A_Clear_MemoryEx function will clear all the graphics and soft fonts
  ///    which stored in the printers memory(RAM or flash memory). Normally
  ///    this function is sent before the A_PrintOut(). Otherwise the graphics
  ///    and fonts will be accumulated, and cause memory overflow. When "memory
  ///    full" occurs, the printer will erase the first-in graphics or fonts.
  ///    To avoid memory full and save processing time, you may send this
  ///    function before the A_PrintOut().
  void A_Clear_MemoryEx(
    int nMode,
  ) {
    assert(nMode >= 0 && nMode <= 2, 'Input a value between 0 and 2');
    return _A_Clear_MemoryEx(
      nMode,
    );
  }

  late final _A_Clear_MemoryExPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
          'A_Clear_MemoryEx');
  late final _A_Clear_MemoryEx =
      _A_Clear_MemoryExPtr.asFunction<void Function(int)>();

  void A_Set_Mirror() {
    return _A_Set_Mirror();
  }

  late final _A_Set_MirrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('A_Set_Mirror');
  late final _A_Set_Mirror = _A_Set_MirrorPtr.asFunction<void Function()>();

  int A_Bar2d_RSS(
    int x,
    int y,
    int ori,
    int ratio,
    int height,
    int rtype,
    int mult,
    int seg,
    ffi.Pointer<ffi.Int8> data1,
    ffi.Pointer<ffi.Int8> data2,
  ) {
    return _A_Bar2d_RSS(
      x,
      y,
      ori,
      ratio,
      height,
      rtype,
      mult,
      seg,
      data1,
      data2,
    );
  }

  late final _A_Bar2d_RSSPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_RSS');
  late final _A_Bar2d_RSS = _A_Bar2d_RSSPtr.asFunction<
      int Function(int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  int A_Bar2d_QR_M(
    int x,
    int y,
    int ori,
    int mult,
    int value,
    int model,
    int error,
    int mask,
    int dinput,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_QR_M(
      x,
      y,
      ori,
      mult,
      value,
      model,
      error,
      mask,
      dinput,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_QR_MPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int8,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_QR_M');
  late final _A_Bar2d_QR_M = _A_Bar2d_QR_MPtr.asFunction<
      int Function(int, int, int, int, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Int8>)>();

  int A_Bar2d_QR_A(
    int x,
    int y,
    int ori,
    int mult,
    int value,
    int mode,
    int numeric,
    ffi.Pointer<ffi.Int8> data,
  ) {
    return _A_Bar2d_QR_A(
      x,
      y,
      ori,
      mult,
      value,
      mode,
      numeric,
      data,
    );
  }

  late final _A_Bar2d_QR_APtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Int8,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>)>>('A_Bar2d_QR_A');
  late final _A_Bar2d_QR_A = _A_Bar2d_QR_APtr.asFunction<
      int Function(int, int, int, int, int, int, int, ffi.Pointer<ffi.Int8>)>();

  int A_GetNetPrinterBufferLen() {
    return _A_GetNetPrinterBufferLen();
  }

  late final _A_GetNetPrinterBufferLenPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'A_GetNetPrinterBufferLen');
  late final _A_GetNetPrinterBufferLen =
      _A_GetNetPrinterBufferLenPtr.asFunction<int Function()>();

  int A_EnumNetPrinter(
    ffi.Pointer<ffi.Int8> buf,
  ) {
    return _A_EnumNetPrinter(
      buf,
    );
  }

  late final _A_EnumNetPrinterPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'A_EnumNetPrinter');
  late final _A_EnumNetPrinter =
      _A_EnumNetPrinterPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  int A_CreateNetPort(
    int nPort,
  ) {
    return _A_CreateNetPort(
      nPort,
    );
  }

  late final _A_CreateNetPortPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'A_CreateNetPort');
  late final _A_CreateNetPort =
      _A_CreateNetPortPtr.asFunction<int Function(int)>();

  int A_Prn_Text_TrueType_Uni(
    int x,
    int y,
    int FSize,
    ffi.Pointer<ffi.Int8> FType,
    int Fspin,
    int FWeight,
    int FItalic,
    int FUnline,
    int FStrikeOut,
    ffi.Pointer<ffi.Int8> id_name,
    ffi.Pointer<ffi.Int8> data,
    int format,
    int mem_mode,
  ) {
    return _A_Prn_Text_TrueType_Uni(
      x,
      y,
      FSize,
      FType,
      Fspin,
      FWeight,
      FItalic,
      FUnline,
      FStrikeOut,
      id_name,
      data,
      format,
      mem_mode,
    );
  }

  late final _A_Prn_Text_TrueType_UniPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Int32)>>('A_Prn_Text_TrueType_Uni');
  late final _A_Prn_Text_TrueType_Uni = _A_Prn_Text_TrueType_UniPtr.asFunction<
      int Function(int, int, int, ffi.Pointer<ffi.Int8>, int, int, int, int,
          int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int, int)>();

  int A_Prn_Text_TrueType_UniB(
    int x,
    int y,
    int FSize,
    ffi.Pointer<ffi.Int8> FType,
    int Fspin,
    int FWeight,
    int FItalic,
    int FUnline,
    int FStrikeOut,
    ffi.Pointer<ffi.Int8> id_name,
    ffi.Pointer<ffi.Int8> data,
    int format,
    int mem_mode,
  ) {
    return _A_Prn_Text_TrueType_UniB(
      x,
      y,
      FSize,
      FType,
      Fspin,
      FWeight,
      FItalic,
      FUnline,
      FStrikeOut,
      id_name,
      data,
      format,
      mem_mode,
    );
  }

  late final _A_Prn_Text_TrueType_UniBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Int32,
              ffi.Int32)>>('A_Prn_Text_TrueType_UniB');
  late final _A_Prn_Text_TrueType_UniB =
      _A_Prn_Text_TrueType_UniBPtr.asFunction<
          int Function(int, int, int, ffi.Pointer<ffi.Int8>, int, int, int, int,
              int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int, int)>();

  int A_GetUSBDeviceInfo(
    int nPort,
    ffi.Pointer<ffi.Int8> pDeviceName,
    ffi.Pointer<ffi.Int32> pDeviceNameLen,
    ffi.Pointer<ffi.Int8> pDevicePath,
    ffi.Pointer<ffi.Int32> pDevicePathLen,
  ) {
    return _A_GetUSBDeviceInfo(
      nPort,
      pDeviceName,
      pDeviceNameLen,
      pDevicePath,
      pDevicePathLen,
    );
  }

  late final _A_GetUSBDeviceInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int32>)>>('A_GetUSBDeviceInfo');
  late final _A_GetUSBDeviceInfo = _A_GetUSBDeviceInfoPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int32>)>();

  int A_Set_EncryptionKey(
    ffi.Pointer<ffi.Int8> encryptionKey,
  ) {
    return _A_Set_EncryptionKey(
      encryptionKey,
    );
  }

  late final _A_Set_EncryptionKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int8>)>>(
          'A_Set_EncryptionKey');
  late final _A_Set_EncryptionKey =
      _A_Set_EncryptionKeyPtr.asFunction<int Function(ffi.Pointer<ffi.Int8>)>();

  int A_Check_EncryptionKey(
    ffi.Pointer<ffi.Int8> decodeKey,
    ffi.Pointer<ffi.Int8> encryptionKey,
    int dwTimeoutms,
  ) {
    return _A_Check_EncryptionKey(
      decodeKey,
      encryptionKey,
      dwTimeoutms,
    );
  }

  late final _A_Check_EncryptionKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
              ffi.Int32)>>('A_Check_EncryptionKey');
  late final _A_Check_EncryptionKey = _A_Check_EncryptionKeyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>, int)>();

  void A_Set_CommTimeout(
    int ReadTotalTimeoutConstant,
    int WriteTotalTimeoutConstant,
  ) {
    return _A_Set_CommTimeout(
      ReadTotalTimeoutConstant,
      WriteTotalTimeoutConstant,
    );
  }

  late final _A_Set_CommTimeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
          'A_Set_CommTimeout');
  late final _A_Set_CommTimeout =
      _A_Set_CommTimeoutPtr.asFunction<void Function(int, int)>();

  void A_Get_CommTimeout(
    ffi.Pointer<ffi.Int32> ReadTotalTimeoutConstant,
    ffi.Pointer<ffi.Int32> WriteTotalTimeoutConstant,
  ) {
    return _A_Get_CommTimeout(
      ReadTotalTimeoutConstant,
      WriteTotalTimeoutConstant,
    );
  }

  late final _A_Get_CommTimeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>)>>('A_Get_CommTimeout');
  late final _A_Get_CommTimeout = _A_Get_CommTimeoutPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Int32>)>();

  void A_Set_LabelForSmartPrint(
    int lablength,
    int gaplength,
  ) {
    return _A_Set_LabelForSmartPrint(
      lablength,
      gaplength,
    );
  }

  late final _A_Set_LabelForSmartPrintPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
          'A_Set_LabelForSmartPrint');
  late final _A_Set_LabelForSmartPrint =
      _A_Set_LabelForSmartPrintPtr.asFunction<void Function(int, int)>();
}
